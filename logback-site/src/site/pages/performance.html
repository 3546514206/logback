<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
    <title>Logback Home</title>
    <link rel="stylesheet" type="text/css" href="css/common.css" />
    <link rel="stylesheet" type="text/css" href="css/screen.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="css/_print.css" media="print" />

  </head>
  <body>
    <script type="text/javascript">prefix='';</script>
    <script src="templates/header.js" type="text/javascript"></script>
    <div id="left">
      <noscript>Please turn on Javascript to view this menu</noscript>
      <script src="templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="templates/right.js" type="text/javascript"></script>
    </div>

    <div id="content">
      
      <h2>Performance using asynchronous logging</h2>

      <p>Log4j 1.2 as well as logback have supported asynchronous
      logging for many years by the way of
      <code>AsyncAppender</code>. This appender essentially collects
      newly created logging events, as produced by the application,
      into a buffer. The events in the buffer are then processed by a
      dedicated worker thread which writes the events to their
      destination, be it a file, a remote server or a database.
      </p>

      <p>Thus, from the application's point of view, the latency cost
      of logging is reduced to placing a logging event in a buffer
      local to the JVM. Such a handing-off operation can be performed
      with a throughput of roughly 1'000'000 operations per second or a
      microsecond per operation. If the destination of the event is a
      database with a throughput of 200 operations per second, the
      performance gain can be very significant.</p>

      <p>Asynchronous logging still has to obey they laws of the
      physical universe. If the rate of arrival of logging events is
      consistently higher than the rate at which the events can be
      written to destination, the buffer within
      <code>AsyncAppender</code> will become full and the application
      will be able hand off events to <code>AsyncAppender</code>'s
      buffer at the rate the events are actually written to
      destination.      
      </p>

      <p>For example, if the <code>FileAppender</code> can write
      100'000 events per second to disk, that is at a cost of 10
      microseconds per event written, than if your application logs
      101'000 events per second, than the throughput observed by your
      application will be 100'000 events written per
      second. AsyncAppender's buffer will not be able to compensate
      for the extra 1000 events per second. We say that the
      <code>AsyncAppender</code> is overwhelmed.</p>

      <p>When the <code>AsyncAppender</code> is overwhelmed, your
      application will be paying the cost of moving events in and out
      of <code>AsyncAppender</code>'s buffer in addition to sending
      events to destination. Thus, when we talk about asynchronous
      logging performance, we need to consider the performance of
      logging when the <code>AsyncAppender</code> is overwhelmed. A
      second consideration is whether asynchronous logging buckles
      under pressure of many producer threads all contending for
      AsyncAppender's buffer.
      </p>
      
      <p>Therefore, any asynchronous logging performance test should
      yield information about the overhead of asynchronous logging
      (when overwhelmed) and its behavior in presence of many
      producer threads.
      </p>

      <p>We have chosen to use <code>FileAppender</code> in
      conjunction with <code>AsyncAppender</code>. Not only is
      <code>FileAppender</code> the mostly used appender, it is fast
      enough so that any differences in asynchronous logging overhead
      can be noticeable. Had we used <code>DBAppender</code>, all
      asynchronous implementations would have the same performance
      with no noticeable differences. </p>

      <h3>Comparing apples to apples</h3>

      <p>The source code for the performance tests can be found in the
      <a href="https://github.com/ceki/logback-perf">logback-perf</a>
      project. We compare the performance of log4j version 1.2.17,
      log4j 2.14.1 and logback 1.3.0-alpha10. </p>
      
      <p>We have taken care to specify the same buffer size,
      i.e. 256KB, for all <code>FileAppender</code> instances across
      frameworks and using identical patterns. Lossy behavior (when
      the buffer is full) is turned off for logback's
      <code>AsyncAppender</code>. It is turned off by default for
      log4j 1.2 and I assume the same for log4j2.</p>

      <p>Below are thebenchmak figures when ran under Windows 10, JDK
      16, Intel i7-6770HQ CPU and an WDC NVMe WDS512G1XOC hard disk
      with 800MB/sec sequential write throughput.</p>
      
      <table  class="bodyTable alignRight striped">
        <tr>
          <th>Threads</th>
          <th>log4j synchronous</th>
          <th>log4j asynchronous</th>
          <th>log4j2 synchronous</th>
          <th>log4j2 asynchronous</th>
          <th>logback 1.3.0 synchronous</th>
          <th>logback 1.3.0 asynchronous</th>
          <th>Unit</th>
        </tr>

        <tr>
          <td>1</td>
          <td>987.08</td>
          <td>745.34</td>
          <td>884.33</td>
          <td>844.67</td>
          <td>2,139.83</td>
          <td>1,760.30</td>
          <td>"ops/ms"</td>
        </tr>

        <tr>
          <td>2</td>
          <td>542.27</td>
          <td>716.09</td>
          <td>1,220.76</td>
          <td>819.40</td>
          <td>2,276.77</td>
          <td>1,821.36</td>
          <td>"ops/ms"</td>
        </tr>
        <tr>
          <td>4</td>
          <td>639.86</td>
          <td>676.35</td>
          <td>1,406.60</td>
          <td>770.27</td>
          <td>1,836.99</td>
          <td>1,799.39</td>
          <td>"ops/ms"</td>          
        </tr>
        <tr>
          <td>8</td>
          <td>633.13</td>
          <td>726.21</td>
          <td>1257.63</td>
          <td>733.25</td>
          <td>1787.62</td>
          <td>1774.99</td>
          <td>"ops/ms"</td>          
        </tr>
        <tr>
          <td>16</td>
          <td>585.134</td>
          <td>693.747</td>
          <td>1211.313</td>
          <td>722.345</td>
          <td>1813.098</td>
          <td>1815.107</td>
          <td>"ops/ms"</td>          
        </tr>

        <tr>
          <td>32</td>
          <td>643.851</td>
          <td>657.082</td>
          <td>1203.27</td>
          <td>704.08</td>
          <td>1782.814</td>
          <td>1751.212</td>
          <td>"ops/ms"</td>          
        </tr>

        <tr>
          <td>32</td>
          <td>576.676</td>
          <td>696.216</td>
          <td>1236.377</td>
          <td>726.153</td>
          <td>1740.279</td>
          <td>1644.819</td>
          <td>"ops/ms"</td>          
        </tr>
      </table>      

      <p>Here is the table presented as a chart.</p>
      
      <p>
        <a href="images/perf/sync-async-perf.jpg">
          <img src="images/perf/sync-async-perf.jpg" alt="Click to enlarge" height="400"/>
        </a>
      </p>

      <p
      
      <script src="templates/footer.js" type="text/javascript"></script>	
    </div>
  </body>
</html>
